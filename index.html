<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spin the Wheel - Roleta Interativa</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Menu Hambúrguer -->
    <button class="hamburger-menu" id="hamburgerMenu" aria-label="Abrir menu">
        <span></span>
        <span></span>
        <span></span>
    </button>

    <!-- Modal/Drawer para opções -->
    <div class="options-modal" id="optionsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Opções da Roleta</h2>
                <button class="close-modal" id="closeModal" aria-label="Fechar">×</button>
            </div>
            <div class="modal-body">
                <label for="entriesTextarea">Digite os nomes (um por linha):</label>
                <textarea id="entriesTextarea" placeholder="Choice 1&#10;Choice 2&#10;Choice 3&#10;..."></textarea>
                <div class="entries-info" id="entriesInfo">0 opções</div>
            </div>
        </div>
    </div>

    <!-- Main Container - Roleta Centralizada -->
    <div class="main-container">
        <div class="wheel-container">
            <div class="wheel-frame">
                <div class="wheel-lights" id="wheelLights">
                    <!-- Lights will be generated by JavaScript -->
                </div>
                <div class="wheel-inner">
                        <svg class="wheel-svg" id="wheel" viewBox="0 0 700 700">
                            <!-- Segments will be generated by JavaScript as <path> elements -->
                        </svg>
                    <div class="wheel-center">
                        <svg class="star-icon" viewBox="0 0 24 24" fill="#FFD700">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                </div>
                <div class="wheel-pointer"></div>
            </div>
        </div>
    </div>

    <script>
        // Lista de opções - cada nome = uma fatia
        let options = ['Choice 1', 'Choice 2', 'Choice 3', 'Choice 4', 'Choice 5', 'Choice 6', 'Choice 7', 'Choice 8'];
        let isSpinning = false;

        const wheel = document.getElementById('wheel');
        const wheelLights = document.getElementById('wheelLights');
        const entriesTextarea = document.getElementById('entriesTextarea');
        const entriesInfo = document.getElementById('entriesInfo');
        const hamburgerMenu = document.getElementById('hamburgerMenu');
        const optionsModal = document.getElementById('optionsModal');
        const closeModal = document.getElementById('closeModal');

        /**
         * Gera uma cor única para cada fatia usando HSL
         * Cada fatia recebe uma cor diferente baseada no seu índice
         * @param {number} index - Índice da fatia (0, 1, 2, ...)
         * @param {number} total - Total de fatias
         * @returns {string} Cor em formato hexadecimal
         */
        function generateUniqueColor(index, total) {
            // Distribuir uniformemente no círculo cromático (0-360 graus)
            const hue = (index * 360) / total;
            // Saturação e luminosidade constantes para harmonia visual
            const saturation = 70; // 70% de saturação
            const lightness = 50;  // 50% de luminosidade
            
            // Converter HSL para RGB e depois para hexadecimal
            const hslToRgb = (h, s, l) => {
                s /= 100;
                l /= 100;
                const k = (n) => (n + h / 30) % 12;
                const a = s * Math.min(l, 1 - l);
                const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
                return [255 * f(0), 255 * f(8), 255 * f(4)];
            };
            
            const [r, g, b] = hslToRgb(hue, saturation, lightness);
            const toHex = (n) => Math.round(n).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        
        /**
         * Determina se o texto deve ser branco ou preto baseado na luminosidade da cor
         * @param {string} hexColor - Cor em hexadecimal
         * @returns {string} '#ffffff' ou '#000000'
         */
        function getTextColor(hexColor) {
            // Converter hex para RGB
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            
            // Calcular luminosidade relativa
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            
            // Se a cor for escura (luminosidade < 0.5), usar texto branco
            return luminance < 0.5 ? '#ffffff' : '#000000';
        }

        function createLights() {
            wheelLights.innerHTML = '';
            const numLights = 18;
            const anglePerLight = 360 / numLights;
            
            // ━━━━━━━━━━━━━━━━━━━━━━
            // CÁLCULO DO RAIO FIXO PARA TODAS AS LUZES (dinâmico baseado no tamanho atual)
            // ━━━━━━━━━━━━━━━━━━━━━━
            // Obter o tamanho atual do wheel-frame (que contém as luzes)
            const wheelFrame = document.querySelector('.wheel-frame');
            if (!wheelFrame) return;
            
            const containerSize = wheelFrame.offsetWidth || 700; // Fallback para 700px
            const raioExterno = containerSize / 2;
            const espessuraDaBorda = 18; // padding da borda
            // Raio fixo: centro da borda (raio externo - metade da espessura)
            const raioLuz = raioExterno - (espessuraDaBorda / 2);

            for (let i = 0; i < numLights; i++) {
                const light = document.createElement('div');
                light.className = 'wheel-light';
                
                // Calcular ângulo
                const angle = i * anglePerLight;
                const angleRad = (angle - 90) * Math.PI / 180; // -90 para começar no topo
                
                // Posicionar usando o MESMO raio fixo para todas as luzes
                // Usar coordenadas relativas ao centro (50% do container)
                const x = raioLuz * Math.cos(angleRad);
                const y = raioLuz * Math.sin(angleRad);
                
                // Posicionar exatamente no centro da borda usando calc
                light.style.left = `calc(50% + ${x}px)`;
                light.style.top = `calc(50% + ${y}px)`;
                light.style.transform = 'translate(-50%, -50%)';
                
                // Delay alternado para criar efeito de movimento contínuo
                light.style.animationDelay = `${i * 0.15}s`;
                wheelLights.appendChild(light);
            }
        }

        /**
         * Cria os segmentos radiais da roleta usando SVG com arcos matemáticos precisos
         * REGRA FUNDAMENTAL: Cada fatia ocupa exatamente ANGULO = 360 / totalDeOpcoes
         */
        function createWheel() {
            wheel.innerHTML = '';
            const numOptions = options.length;
            
            // ━━━━━━━━━━━━━━━━━━━━━━
            // 1️⃣ CÁLCULO ANGULAR OBRIGATÓRIO
            // ━━━━━━━━━━━━━━━━━━━━━━
            const angleStep = 360 / numOptions; // Ângulo exato por fatia
            
            // Dimensões do SVG (viewBox 0 0 700 700)
            const cx = 350; // Centro X
            const cy = 350; // Centro Y
            const radius = 332; // Raio interno (até a borda - 700/2 - 18px de padding)
            
            // Converter graus para radianos
            const toRad = (deg) => (deg - 90) * Math.PI / 180; // -90 para começar no topo
            
            // Criar cada segmento como SVG path com arco
            options.forEach((option, index) => {
                // ━━━━━━━━━━━━━━━━━━━━━━
                // CÁLCULO DOS ÂNGULOS
                // ━━━━━━━━━━━━━━━━━━━━━━
                const startAngle = index * angleStep; // Ângulo inicial
                const endAngle = startAngle + angleStep; // Ângulo final
                
                // Converter para radianos
                const startRad = toRad(startAngle);
                const endRad = toRad(endAngle);
                
                // Calcular pontos do arco na borda do círculo
                const x1 = cx + radius * Math.cos(startRad);
                const y1 = cy + radius * Math.sin(startRad);
                const x2 = cx + radius * Math.cos(endRad);
                const y2 = cy + radius * Math.sin(endRad);
                
                // Flag para arco grande (se o ângulo > 180 graus)
                const largeArcFlag = angleStep > 180 ? 1 : 0;
                
                // ━━━━━━━━━━━━━━━━━━━━━━
                // CRIAR PATH COM ARCO (comando A do SVG)
                // Sintaxe: A rx ry x-axis-rotation large-arc-flag sweep-flag x y
                // ━━━━━━━━━━━━━━━━━━━━━━
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const pathData = [
                    `M ${cx} ${cy}`, // Move para o centro
                    `L ${x1} ${y1}`, // Linha do centro até o início do arco
                    `A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}`, // Arco circular
                    'Z' // Fechar o path (linha do ponto final de volta ao centro)
                ].join(' ');
                
                // ━━━━━━━━━━━━━━━━━━━━━━
                // GERAR COR ÚNICA PARA CADA FATIA
                // ━━━━━━━━━━━━━━━━━━━━━━
                // Cada fatia recebe uma cor única baseada no índice
                const uniqueColor = generateUniqueColor(index, numOptions);
                
                path.setAttribute('d', pathData);
                path.setAttribute('fill', uniqueColor);
                path.setAttribute('class', `wheel-segment-path`);
                
                wheel.appendChild(path);
            });
            
            // ━━━━━━━━━━━━━━━━━━━━━━
            // 3️⃣ TEXTO COM LEITURA RADIAL PADRÃO DE ROLETA
            // ━━━━━━━━━━━━━━━━━━━━━━
            options.forEach((option, index) => {
                const startAngle = index * angleStep;
                // Calcular ângulo médio da fatia
                const angleMid = startAngle + (angleStep / 2);
                const middleRad = toRad(angleMid);
                
                // Posição do texto mais próximo da borda externa (50% do raio)
                const textRadius = radius * 0.50;
                const textX = cx + textRadius * Math.cos(middleRad);
                const textY = cy + textRadius * Math.sin(middleRad);
                
                // Criar elemento de texto SVG
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', textX);
                text.setAttribute('y', textY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                // Fonte maior e legível (proporcional ao tamanho da roleta)
                // Baseado no viewBox 520x520, usar tamanho proporcional
                const fontSize = Math.max(24, Math.min(32, 520 / (numOptions * 2.5)));
                text.setAttribute('font-size', fontSize);
                text.setAttribute('font-weight', '600');
                text.setAttribute('font-family', 'Arial, sans-serif');
                text.setAttribute('class', 'wheel-segment-text');
                
                // ━━━━━━━━━━━━━━━━━━━━━━
                // CÁLCULO CORRETO DA ROTAÇÃO (LEITURA RADIAL)
                // ━━━━━━━━━━━━━━━━━━━━━━
                // Regra: rotation = angleMid - 90°
                // Isso alinha o texto ao RAIO (base aponta para o centro, topo para a borda)
                let textRotation = angleMid - 90;
                
                // REGRA ANTI-TEXTO-DE-CABEÇA-PARA-BAIXO:
                // Se rotation > 90° e rotation < 270°, inverter
                if (textRotation > 90 && textRotation < 270) {
                    textRotation = textRotation + 180;
                }
                
                text.setAttribute('transform', `rotate(${textRotation} ${textX} ${textY})`);
                
                // ━━━━━━━━━━━━━━━━━━━━━━
                // COR DO TEXTO BASEADA NA LUMINOSIDADE DA COR DA FATIA
                // ━━━━━━━━━━━━━━━━━━━━━━
                // Usar a mesma cor única gerada para determinar o contraste do texto
                const segmentColor = generateUniqueColor(index, numOptions);
                const textColor = getTextColor(segmentColor);
                text.setAttribute('fill', textColor);
                
                text.textContent = option;
                wheel.appendChild(text);
            });
            
            // Preservar rotação atual após recriar a roleta
            if (currentRotation !== undefined) {
                const wheelInner = document.querySelector('.wheel-inner');
                wheelInner.style.transform = `rotate(${currentRotation}deg)`;
            }
            
            // Aplicar rotação ao SVG também se necessário
            if (currentRotation !== undefined) {
                wheel.style.transform = `rotate(${currentRotation}deg)`;
            }
            
            // Recriar luzes para se ajustarem ao novo tamanho
            createLights();
        }

        /**
         * Atualiza as opções da roleta baseado no texto inserido
         * Cada linha = uma fatia
         */
        function updateFromTextarea() {
            const text = entriesTextarea.value.trim();
            // Separar por linhas e filtrar linhas vazias
            const lines = text.split('\n')
                .map(line => line.trim())
                .filter(line => line.length > 0);
            
            // Se houver pelo menos uma opção, atualizar
            if (lines.length > 0) {
                options = lines;
                createWheel();
                updateEntriesInfo();
            } else if (text === '') {
                // Se o campo estiver vazio, manter pelo menos uma opção padrão
                options = ['Choice 1'];
                createWheel();
                updateEntriesInfo();
            }
        }

        /**
         * Atualiza a informação de quantas opções existem
         */
        function updateEntriesInfo() {
            entriesInfo.textContent = `${options.length} ${options.length === 1 ? 'opção' : 'opções'}`;
        }

        let currentRotation = 0;

        function spinWheel() {
            if (isSpinning) return;
            
            isSpinning = true;
            const wheelFrame = document.querySelector('.wheel-frame');
            const wheelInner = document.querySelector('.wheel-inner');
            wheelFrame.style.cursor = 'not-allowed';

            const numOptions = options.length;
            const anglePerSection = 360 / numOptions;
            
            // Gira múltiplas vezes + um ângulo aleatório
            const spins = 5 + Math.random() * 5; // 5-10 voltas completas
            const randomAngle = Math.random() * 360;
            const totalRotation = spins * 360 + randomAngle;
            
            // Ajusta para que o ponteiro aponte para o centro de uma seção
            const normalizedAngle = totalRotation % 360;
            const selectedIndex = Math.floor((360 - normalizedAngle) / anglePerSection) % numOptions;
            const adjustedRotation = totalRotation - (normalizedAngle % anglePerSection) + (anglePerSection / 2);

            // Adiciona à rotação atual
            currentRotation += adjustedRotation;

            // Apenas a roleta interna gira, não a borda
            wheelInner.style.transition = 'transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99)';
            wheelInner.style.transform = `rotate(${currentRotation}deg)`;

            setTimeout(() => {
                // Normaliza a rotação para evitar valores muito grandes
                currentRotation = currentRotation % 360;
                wheelInner.style.transition = 'none';
                wheelInner.style.transform = `rotate(${currentRotation}deg)`;
                isSpinning = false;
                wheelFrame.style.cursor = 'pointer';
            }, 4000);
        }

        // Event listeners
        wheel.addEventListener('click', spinWheel);
        
        // Sincronizar textarea com roleta - cada linha = uma fatia
        entriesTextarea.addEventListener('input', updateFromTextarea);
        entriesTextarea.addEventListener('paste', () => {
            setTimeout(updateFromTextarea, 10);
        });
        
        // Menu hambúrguer
        hamburgerMenu.addEventListener('click', () => {
            optionsModal.classList.add('active');
        });
        
        closeModal.addEventListener('click', () => {
            optionsModal.classList.remove('active');
        });
        
        // Fechar modal ao clicar fora
        optionsModal.addEventListener('click', (e) => {
            if (e.target === optionsModal) {
                optionsModal.classList.remove('active');
            }
        });

        // Inicialização
        entriesTextarea.value = options.join('\n');
        createWheel(); // createWheel já chama createLights() internamente
        updateEntriesInfo();
    </script>
</body>
</html>
